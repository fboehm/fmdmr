---
title: "Barton et al. GWAS summary statistics & FMD GWAS meta-analysis summary statistics"
author: "Fred Boehm"
toc: true
number-sections: true
format: 
    html:
        code-fold: true
        embed-resources: true
    gfm: default
---

We want to "explore" the results files to see how many SNPs are available in each, and to see 
how many SNPs are in both files. This information will inform 2-sample MR studies to 
assess the causal effect of FMD on creatinine levels.

First, we read into R the FMD summary statistics file.



```{r}
library(magrittr)
# https://cran.r-project.org/web/packages/LDlinkR/vignettes/LDlinkR.html
# follow steps at above url to use LDlinkR to get LD matrix for use with MendelianRandomization R pkg
ld_token <- "3fbdb0673b22"

```


```{r}
fmd_lead_snps_file <- here::here("data", "fmd", "katz_fmd_snps.csv") # snps from Katz et al. 2022 Supp Info Table SII.
fmd_lead_snps <- read.csv(fmd_lead_snps_file, stringsAsFactors = FALSE, header = FALSE) %>% as.character()
fmd_file <- here::here("data", "fmd", "GCST90026612_buildGRCh37.tsv")
fmd_tib <- vroom::vroom(fmd_file) 
```
dat
```{r get_proxies}
# get proxies for all 26 fmd_lead_snps
# query biomaRt & LDlink if the output file doesn't exist
ensembl <- biomaRt::useMart("ENSEMBL_MART_SNP", dataset = "hsapiens_snp")
atts <- biomaRt::listAttributes(ensembl)
snp_ann <- biomaRt::getBM(attributes = c("refsnp_id", "chr_name", "chrom_start", "chrom_end"),
                filters = "snp_filter",
                values = fmd_lead_snps,
                mart = ensembl) %>%
                tibble::as_tibble()
snp_ann %>%
    print(n = nrow(.))   
# function to choose SNPs for LDlink query
#' @param dat a tibble with columns 'chromosome', 'base_pair_location'
#' @param lead_snp_annot a tibble with exactly one row and with columns 'lead_snp', 'chr', 'position'
#' @param n_snps an integer - the number of SNPs to return
get_nearby_snps <- function(dat, lead_snp_annot, n_snps = 5000, info_threshold = 0.9, max_distance = 10000){
    nearby_snps <- dat %>%
        dplyr::filter(chromosome == as.integer(lead_snp_annot$chr)) %>%
        dplyr::mutate(distance = abs(base_pair_location - lead_snp_annot$position)) %>%
        dplyr::arrange(distance) %>%
        dplyr::filter(distance < max_distance) %>%
        dplyr::slice(1:n_snps) 
    return(nearby_snps)
}

#' Query LDlinkR for LD matrix for a set of SNPs
#' @param snps a character vector of SNP rsids or appropriately formatted chr_pos values - be sure to include lead snp's rsid
#' @param ld_token a character vector of length 1 - the token for LDlinkR
#' @param genome_build a character vector of length 1 - the genome build for LDlinkR
#' @param pop a character vector of length 1 - the population for LDlinkR
#' @return a matrix of LD values for the SNPs in 'snps'
#' @details see vignette here for use of LDlinkR functions: https://cran.r-project.org/web/packages/LDlinkR/vignettes/LDlinkR.html. If `snps` inputs chr_pos values, be sure that each begins with "chr"
get_ld_matrix <- function(snps, ld_token, genome_build, pop = "CEU"){
    stopifnot(length(snps) <= 1000)
    # get LD matrix for snps
    ld_mat <- LDlinkR::LDmatrix(snps = snps, token = ld_token, genome_build = genome_build, pop = pop)
    return(ld_mat)
}

#' Get rs_id from chromosome and position
#' 
#' @param chr a character vector of length 1- the chromosome
#' @param pos a numeric vector of snp positions on the chromosome chr
get_rsid_from_chr_pos <- function(chr, pos, host = "https://grch37.ensembl.org"){
    # get rsid from chromosome and position
    dataset <- "hsapiens_snp"
    attributes <- c("refsnp_id", "chr_name", "chrom_start", "chrom_end")
    # create a biomaRt object for the GRCh37 reference genome
    mart <- biomaRt::useMart(biomart = "ENSEMBL_MART_SNP", dataset = dataset, host = host)
    # retrieve the SNP information using biomaRt
    results <- list()
    for (pp in pos){
        filters <- list(chr_name = as.character(chr), start = pp, end = pp) # to return all snps between start and end
        results[[as.character(pp)]] <- biomaRt::getBM(attributes = attributes, filters = filters, mart = mart) %>%
            tibble::as_tibble() %>%
            dplyr::filter(chrom_start == chrom_end) %>%
            dplyr::filter(stringr::str_starts(refsnp_id, "rs"))
        cat("Retrieved SNP information for position ", pp, " on chromosome ", chr, "\n")
    }
     
    tib <- purrr::discard(results, ~nrow(.x) == 0) %>%
        dplyr::bind_rows()
    return(tib)
}
####
#' Organize outputted LD matrix (a data.frame) from LDlink into 3-column tibble & discard NAs 
#' 
#' @param ldlink_output a data.frame from LDlinkR::LDmatrix
#' @param lead_snp_rs_id a character vector of length 1 - the rsid of the lead SNP
#' @param snp_vec a character vector of SNPs to check if LDlink output is in the vector snp_vec
organize_ldlink_output <- function(ldlink_output){
    out <- ldlink_output %>% 
        dplyr::rename(row_name = RS_number) %>% # column RS_number is hardcoded because it's always in the LDlinkR output
        tidyr::gather(column_name, value, - row_name) %>%
        dplyr::filter(stringr::str_starts(string = column_name, pattern = "rs")) %>%
        dplyr::filter(!is.na(value)) %>%
        dplyr::arrange(dplyr::desc(value)) 
    return(out)
}

#' Choose proxy SNPs for a single lead SNP from the output of organize_ldlink_output.
#' 
#' @param ldlink_output a tibble with columns 'row_name', 'value', 'in_snp_set'
#' @param ld_threshold a numeric value - the threshold for LD to be considered a proxy
#' @return a tibble with columns 'row_name', 'value', 'in_snp_set' and one row per proxy SNP
get_proxies_tib <- function(ldlink_output, ld_threshold = 0.8){
    out <- ldlink_output %>%
        dplyr::filter(value > ld_threshold) 
    return(out)
}

# get LD matrix for each lead SNP after renaming and filtering snp_ann to only include SNPs with a chromosome number
sa <- snp_ann %>%
    dplyr::filter(!is.na(as.integer(chr_name))) %>%
    dplyr::mutate(chr = as.integer(chr_name)) %>%
    dplyr::mutate(lead_snp = refsnp_id, position = chrom_start) %>%
    dplyr::select( - chrom_end, - chrom_start, - refsnp_id, - chr_name) %>%
    dplyr::mutate(chr_pos = paste0("chr", chr, ":", position)) %>%
    dplyr::mutate(in_fmd = lead_snp %in% fmd_tib$SNP) %>%
    dplyr::mutate(in_barton = chr_pos %in% barton_tib$chr_pos) 
```




`LDlinkR::LDmatrix` takes as inputs up to 1000 SNPs at a time.



```{r, results = "asis"}
outcomes <- c("CystatinC", "Creatinine")
for (outcome in outcomes){
    if (outcome == "CystatinC"){
        barton_file <- here::here("data", "barton2021_cystatinC", "GCST90025945_buildGRCh37.tsv")
    }
    if (outcome == "Creatinine"){
        barton_file <- here::here("data", "barton2021_creatinine", "GCST90025946_buildGRCh37.tsv")
    }
    barton_tib <- vroom::vroom(barton_file) %>%
        dplyr::mutate(chr_pos = paste0("chr", chromosome, ":", base_pair_location))
    # find shared snps
    # get proxies for each lead SNP
    # if a lead SNP is itself present in the fmd data, then we don't need a proxy for it in the FMD data
    # if a lead SNP is not present in the fmd data, then we need a proxy for it from the FMD data
    # some SNPs are in both FMD and barton data, apparently.
    # most lead SNPs are not in the barton data. Thus, we need to find proxies for them that are in the barton data.
    # unfortunately, we need to query LDlinkR for each possible proxy. We can limit to nearby SNPs in high LD. That is, 
    # we can first choose the lead SNPs that need proxies in the barton data, then choose the proxies for those lead SNPs (ie, from the barton SNPs)
    proxies <- list()
    for (row_num in seq_len(nrow(sa))){ #loop over lead SNPs
        one_snp_tib <- sa %>% dplyr::slice(row_num)
        rs <- one_snp_tib$lead_snp
        # 0. check if lead SNP is in barton and FMD data sets
        # join one_snp_tib with barton_tib & check number of rows of result
        # if lead SNP is not in barton data, then we need a proxy for it 
        snp_tib <- get_nearby_snps(dat = barton_tib, lead_snp_annot = one_snp_tib) %>%
            dplyr::mutate(lead_snp = rs) %>%
            dplyr::relocate(chr_pos, distance, lead_snp)
        # get rsids for nearby barton snps
        if (nrow(snp_tib) > 0){
            chr <- snp_tib$chromosome[1]
            pos <- snp_tib$base_pair_location
            st2 <- get_rsid_from_chr_pos(chr, pos) %>%
                dplyr::rename(pos = chrom_start) %>%
                dplyr::mutate(chr = as.integer(chr_name)) %>%
                dplyr::select(- chrom_end, - chr_name) %>%
                dplyr::right_join(snp_tib, by = c("chr" = "chromosome", "pos" = "base_pair_location")) %>%
                dplyr::filter(!is.na(refsnp_id)) %>%
                dplyr::mutate(in_fmd_snps = refsnp_id %in% fmd_tib$SNP) %>%
                dplyr::mutate(lead_snp = one_snp_tib$lead_snp, lead_snp_pos = one_snp_tib$position) %>%
                dplyr::mutate(chr_pos = paste0("chr", chr, ":", pos)) %>%
                dplyr::mutate(in_barton_snps = chr_pos %in% barton_tib$chr_pos) %>%
                dplyr::relocate(lead_snp, lead_snp_pos, in_fmd_snps, in_barton_snps)
                
            # 1. get barton snps near the lead SNP. Note that lead SNP is taken from fmd data
            # 1b. Check if barton SNP rs ids are in fmd data
            st2_in_fmd <- st2 %>%
                dplyr::filter(in_fmd_snps)
            proxies[[rs]] <- st2_in_fmd
        }
    }
    # add ld value to each row of each tibble in proxies object
            # 2. get LD for pairs of barton snps (where both members of pair are near lead SNP) - note that the LDlinkR output has rs ids only.
            # 3. get positions (chr and bp) for barton rsids from step 2
            # 3. get barton snps with high LD with lead SNP
    proxy_tibs <- list()
    for (i in seq_along(proxies)){
        if (nrow(proxies[[i]]) < 2 || ncol(proxies[[i]]) == 3){
            next
        }
        ld_tib <- get_ld_matrix(snps = c(proxies[[i]]$lead_snp[1], proxies[[i]]$refsnp_id), 
                                ld_token = ld_token) %>%
            tibble::as_tibble()    
        ld_tib_small <- organize_ldlink_output(ldlink_output = ld_tib) %>%
            dplyr::filter(column_name == proxies[[i]]$lead_snp[1])
        # get rs id for SNPs in the barton data
        
        # see if best proxies are in fmd data 
        #foo <- get_proxies_tib(ldlink_output = ld_tib_small, ld_threshold = 0.8)
        proxy_tibs[[i]] <- ld_tib_small %>%
            dplyr::filter(!(row_name == column_name)) %>%
            dplyr::right_join(proxies[[i]], by = c("row_name" = "refsnp_id", "column_name" = "lead_snp")) %>%
            dplyr::rename(proxy_rs_id = row_name, proxy_pos = pos, lead_snp = column_name, ld = value) %>%
            dplyr::relocate(lead_snp, proxy_rs_id, proxy_pos, lead_snp_pos, in_fmd_snps, .after = 1) %>%
            dplyr::arrange(dplyr::desc(ld))
    }
    # get the combined rs ids for the proxies and true snps
    # split proxies into two lists - one where the lead SNP is in fmd data; the other not
    proxies_in_fmd <- proxies %>%
        purrr::discard( ~ncol(.x) > 3 )
    proxies_not_in_fmd <- proxies %>%
        purrr::discard( ~ncol(.x) < 4 )
    proxies_in_fmd %>%
        dplyr::bind_rows() %>%
        dplyr::mutate(chr_pos = paste0("chr", chr, ":", position)) %>%
        dplyr::mutate(in_barton = chr_pos %in% barton_tib$chr_pos)


}
# we now have proxies object


# make a tibble of: lead snps, proxies in fmd, proxies in barton
    small_dat_pre <- fmd_tib %>%
        dplyr::filter(p_value < p_threshold)  %>% # choose pvalue threshold     
        dplyr::inner_join(barton_tib, by = c("chromosome", "base_pair_location"))
    # harmonised? 
    small_dat <- small_dat_pre %>%
        dplyr::mutate(harmonised = OA == ALLELE0)
    all_harmonised <- all.equal(small_dat$harmonised, rep(TRUE, length(small_dat$harmonised)))
    stopifnot(all_harmonised)
    # make ld matrix if ld_file doesn't exist
    if (file.exists(ld_file)){
        ld_mat <- readRDS(ld_file)
    } else {
        ld_list <- list()
        for (chr in 1:22){
            fmd_onechr <- small_dat %>%
                dplyr::filter(chromosome == chr)
            if (nrow(fmd_onechr) > 1){
                foo <- LDlinkR::LDmatrix(fmd_onechr$SNP, 
                        pop = "CEU", 
                        r2d = "r2", 
                        genome_build = "grch37",
                        token = ld_token, 
                        file = FALSE
                        ) 
                
                bar <- foo %>% 
                            dplyr::select(-1) %>%
                            as.matrix() %>%
                            remove_offdiagonal_ones(threshold = 0.99)

                # remove rows & cols for highly correlated SNPs 

                ld_list[[chr]] <- bar
            }
            if (nrow(fmd_onechr) == 1){
                ld_list[[chr]] <- as.matrix(1)
                colnames(ld_list[[chr]]) <- fmd_onechr$SNP      
            }
            if (nrow(fmd_onechr) == 0){
                ld_list[[chr]] <- NA
            }
        }
        # remove NAs
        ld_list_nona <- ld_list[!is.na(ld_list)]
        ld_mat <- as.matrix(Matrix::bdiag(ld_list_nona))
        rn <- do.call(c, lapply(ld_list_nona, colnames))
        rownames(ld_mat) <- rn
        colnames(ld_mat) <- rn
        # save ld matrix
        saveRDS(ld_mat, ld_file)
    }

    # filter to remove highly correlated SNPs
    small_dat_no_ld <- small_dat %>%
        dplyr::filter(SNP %in% rownames(ld_mat))
    ld_mat_small <- ld_mat[rownames(ld_mat) %in% small_dat_no_ld$SNP, 
                            colnames(ld_mat) %in% small_dat_no_ld$SNP]
    print(nrow(small_dat_no_ld))
    # make input object
    input <- MendelianRandomization::mr_input(
                bx = small_dat_no_ld$BETA, 
                bxse = small_dat_no_ld$SE, 
                by = small_dat_no_ld$beta, 
                byse = small_dat_no_ld$standard_error,
                corr = ld_mat_small,
                exposure = "FMD",
                outcome = outcome,
                snps = rownames(ld_mat_small)
            )
    # make header for collection of graphs for each iteration of loop
    cat('\n\n## `', outcome, "with p-value threshold: ", p_threshold, '`\n\n')    
    # MR analyses   
    result <- MendelianRandomization::mr_allmethods(input)
    result@Values %>% 
        dplyr::mutate_if(is.numeric, signif, digits = 2) %>%
        dplyr::mutate("Number of SNPs" = length(result@Data@snps)) %>%
        dplyr::rename("95% CI lower" = 4, "95% CI upper" = 5) %>%
        knitr::kable() %>%
        print()
    ivw_res <- MendelianRandomization::mr_ivw(input, correl = TRUE)
    egger_res <- MendelianRandomization::mr_egger(input, correl = TRUE)

    # MR plots
    MendelianRandomization::mr_plot(input, interactive = FALSE, line = "ivw", labels = TRUE, orientate = TRUE) %>%
        print()
    MendelianRandomization::mr_plot(input, interactive = FALSE, line = "egger", labels = TRUE, orientate = TRUE) %>%
            print()
}
```

```{r}
devtools::session_info()
```

